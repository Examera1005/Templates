# GitLab CI/CD Pipeline
# Comprehensive pipeline for modern applications

stages:
  - security
  - quality
  - test
  - build
  - deploy-staging
  - test-staging
  - deploy-production
  - monitor

variables:
  NODE_VERSION: "18"
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  REGISTRY: $CI_REGISTRY
  IMAGE_TAG: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
  STAGING_URL: "https://staging.yourapp.com"
  PRODUCTION_URL: "https://yourapp.com"

# Templates for reusable job configurations
.node_template: &node_template
  image: node:${NODE_VERSION}-alpine
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - node_modules/
      - .npm/
  before_script:
    - npm ci --cache .npm --prefer-offline

.docker_template: &docker_template
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY

# Security Scanning
security:dependency-scan:
  stage: security
  <<: *node_template
  script:
    - npm audit --audit-level=moderate
    - npx audit-ci --moderate
  artifacts:
    reports:
      dependency_scanning: gl-dependency-scanning-report.json
  rules:
    - if: $CI_MERGE_REQUEST_ID
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

security:secret-scan:
  stage: security
  image: alpine:latest
  before_script:
    - apk add --no-cache git
    - git clone https://github.com/trufflesecurity/truffleHog.git
    - cd truffleHog && go build -o trufflehog main.go
  script:
    - ./truffleHog/trufflehog filesystem . --json > secret-scan-result.json
  artifacts:
    reports:
      secret_detection: secret-scan-result.json
  rules:
    - if: $CI_MERGE_REQUEST_ID
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

security:container-scan:
  stage: security
  <<: *docker_template
  script:
    - docker build -t $IMAGE_TAG .
    - docker run --rm -v /var/run/docker.sock:/var/run/docker.sock 
      -v $PWD:/workspace aquasec/trivy:latest image --format json --output container-scan-result.json $IMAGE_TAG
  artifacts:
    reports:
      container_scanning: container-scan-result.json
  rules:
    - if: $CI_MERGE_REQUEST_ID
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# Code Quality
quality:lint:
  stage: quality
  <<: *node_template
  script:
    - npm run lint:js
    - npm run lint:css
    - npm run lint:format
    - npm run type-check
  artifacts:
    reports:
      codequality: gl-code-quality-report.json
  rules:
    - if: $CI_MERGE_REQUEST_ID
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

quality:sonarqube:
  stage: quality
  image: sonarsource/sonar-scanner-cli:latest
  variables:
    SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"
    GIT_DEPTH: "0"
  cache:
    key: "${CI_JOB_NAME}"
    paths:
      - .sonar/cache
  script:
    - sonar-scanner
  rules:
    - if: $CI_MERGE_REQUEST_ID
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# Testing
test:unit:
  stage: test
  <<: *node_template
  parallel:
    matrix:
      - NODE_VERSION: ["16", "18", "20"]
  script:
    - npm run test:unit
    - npm run test:coverage
  coverage: '/Lines\s*:\s*(\d+\.\d+)%/'
  artifacts:
    reports:
      junit: junit.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
    paths:
      - coverage/
  rules:
    - if: $CI_MERGE_REQUEST_ID
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

test:integration:
  stage: test
  <<: *node_template
  services:
    - postgres:15-alpine
    - redis:7-alpine
  variables:
    POSTGRES_DB: testdb
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    DATABASE_URL: "postgresql://postgres:postgres@postgres:5432/testdb"
    REDIS_URL: "redis://redis:6379"
  script:
    - npm run test:integration
  artifacts:
    reports:
      junit: integration-junit.xml
  rules:
    - if: $CI_MERGE_REQUEST_ID
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

test:e2e:
  stage: test
  <<: *node_template
  services:
    - postgres:15-alpine
    - redis:7-alpine
  variables:
    POSTGRES_DB: testdb
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    DATABASE_URL: "postgresql://postgres:postgres@postgres:5432/testdb"
    REDIS_URL: "redis://redis:6379"
  script:
    - npm run build
    - npm start &
    - sleep 30
    - npm run test:e2e
  artifacts:
    when: on_failure
    paths:
      - tests/e2e/screenshots/
      - tests/e2e/videos/
    expire_in: 1 week
  rules:
    - if: $CI_MERGE_REQUEST_ID
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# Build Stage
build:application:
  stage: build
  <<: *node_template
  script:
    - npm run build
    - echo "BUILD_VERSION=${CI_COMMIT_SHORT_SHA}" > build-info.txt
    - echo "BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> build-info.txt
    - tar -czf build.tar.gz dist/
  artifacts:
    paths:
      - build.tar.gz
      - build-info.txt
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_BRANCH == "develop"
    - if: $CI_COMMIT_TAG

build:docker:
  stage: build
  <<: *docker_template
  script:
    - docker build 
      --build-arg BUILD_VERSION=${CI_COMMIT_SHORT_SHA}
      --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
      -t $IMAGE_TAG .
    - docker push $IMAGE_TAG
    - |
      if [ "$CI_COMMIT_BRANCH" == "$CI_DEFAULT_BRANCH" ]; then
        docker tag $IMAGE_TAG $CI_REGISTRY_IMAGE:latest
        docker push $CI_REGISTRY_IMAGE:latest
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_BRANCH == "develop"
    - if: $CI_COMMIT_TAG

# Staging Deployment
deploy:staging:
  stage: deploy-staging
  image: alpine:latest
  environment:
    name: staging
    url: $STAGING_URL
  before_script:
    - apk add --no-cache curl
    - 'command -v ssh-agent >/dev/null || ( apk add --update openssh )'
    - eval $(ssh-agent -s)
    - echo "$STAGING_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan $STAGING_HOST >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
  script:
    - ssh $STAGING_USER@$STAGING_HOST "
        docker pull $IMAGE_TAG &&
        docker stop app-staging || true &&
        docker rm app-staging || true &&
        docker run -d --name app-staging -p 3000:3000 
        -e NODE_ENV=staging
        -e DATABASE_URL=$STAGING_DATABASE_URL
        $IMAGE_TAG"
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"

test:staging:
  stage: test-staging
  <<: *node_template
  script:
    - sleep 30  # Wait for deployment
    - curl -f $STAGING_URL/health || exit 1
    - npm run test:smoke -- --base-url=$STAGING_URL
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"

test:performance:
  stage: test-staging
  image: sitespeedio/sitespeed.io:latest
  script:
    - sitespeed.io --budget budget.json $STAGING_URL
  artifacts:
    paths:
      - sitespeed-result/
    reports:
      performance: sitespeed-result/data/performance.json
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"

# Production Deployment
deploy:production:
  stage: deploy-production
  image: alpine:latest
  environment:
    name: production
    url: $PRODUCTION_URL
  before_script:
    - apk add --no-cache curl
    - 'command -v ssh-agent >/dev/null || ( apk add --update openssh )'
    - eval $(ssh-agent -s)
    - echo "$PRODUCTION_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan $PRODUCTION_HOST >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
  script:
    - |
      ssh $PRODUCTION_USER@$PRODUCTION_HOST "
        # Blue-Green Deployment
        docker pull $IMAGE_TAG
        
        # Start new version (green)
        docker run -d --name app-green -p 3001:3000 
        -e NODE_ENV=production
        -e DATABASE_URL=$PRODUCTION_DATABASE_URL
        $IMAGE_TAG
        
        # Health check
        sleep 30
        curl -f http://localhost:3001/health || exit 1
        
        # Switch traffic (nginx config update)
        sudo nginx -s reload
        
        # Stop old version (blue)
        docker stop app-blue || true
        docker rm app-blue || true
        
        # Rename green to blue for next deployment
        docker rename app-green app-blue
        docker port app-blue 3000
      "
  when: manual
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG

# Database Migration
migrate:production:
  stage: deploy-production
  <<: *node_template
  environment:
    name: production-db
  script:
    - npm run db:migrate
  variables:
    DATABASE_URL: $PRODUCTION_DATABASE_URL
  when: manual
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG

# Monitoring and Alerts
monitor:health-check:
  stage: monitor
  image: alpine:latest
  script:
    - apk add --no-cache curl
    - curl -f $PRODUCTION_URL/health
    - curl -f $PRODUCTION_URL/api/health
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: delayed
      start_in: 5 minutes

monitor:notify:
  stage: monitor
  image: alpine:latest
  script:
    - apk add --no-cache curl
    - |
      curl -X POST "$SLACK_WEBHOOK_URL" \
        -H 'Content-type: application/json' \
        --data "{
          \"text\":\"ðŸš€ Deployment successful!\",
          \"attachments\":[{
            \"color\":\"good\",
            \"fields\":[{
              \"title\":\"Environment\",
              \"value\":\"Production\",
              \"short\":true
            },{
              \"title\":\"Version\",
              \"value\":\"$CI_COMMIT_SHORT_SHA\",
              \"short\":true
            },{
              \"title\":\"Branch\",
              \"value\":\"$CI_COMMIT_BRANCH\",
              \"short\":true
            },{
              \"title\":\"Pipeline\",
              \"value\":\"$CI_PIPELINE_URL\",
              \"short\":true
            }]
          }]
        }"
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# Rollback Job (Manual)
rollback:production:
  stage: deploy-production
  image: alpine:latest
  environment:
    name: production
    url: $PRODUCTION_URL
  script:
    - echo "Rolling back to previous version..."
    - |
      ssh $PRODUCTION_USER@$PRODUCTION_HOST "
        # Get previous image
        PREVIOUS_IMAGE=\$(docker images $CI_REGISTRY_IMAGE --format 'table {{.Tag}}' | head -n 2 | tail -n 1)
        
        # Deploy previous version
        docker run -d --name app-rollback -p 3002:3000 
        -e NODE_ENV=production
        -e DATABASE_URL=$PRODUCTION_DATABASE_URL
        $CI_REGISTRY_IMAGE:\$PREVIOUS_IMAGE
        
        # Health check
        sleep 30
        curl -f http://localhost:3002/health || exit 1
        
        # Switch traffic
        sudo nginx -s reload
        
        # Clean up
        docker stop app-blue
        docker rename app-rollback app-blue
      "
  when: manual
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH